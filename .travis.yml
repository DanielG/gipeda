# NB: don't set `language: haskell` here

sudo: false
cache:
  directories:
  - $HOME/.stack/

# Here we test both stack builds, which offer a controlled package
# set, and "bleeding edge" builds which use the GHC resolver to grab
# the latest off hackage.
matrix:
  include:
    # Default: Use whichever is embedded in stack.yaml currently:
    - env: STACK_RESOLVER=
      addons: {apt: {packages: [libgmp-dev]}}

    # Test with an older GHC, 7.8.4:
    - env: STACK_RESOLVER=lts-2.22
#      addons: {apt: {packages: [ghc-7.8.4,happy-1.19.4,alex-3.1.3],sources: [hvr-ghc]}}
      
    # This is nondeterministic; the latest nightly:
    - env: STACK_RESOLVER=nightly
      addons: {apt: {packages: [libgmp-dev]}}

    # Try to use the very latest packages here, so that we catch
    # failures before they get to stackage:
    - env: STACK_RESOLVER=ghc-7.8
#      addons: {apt: {packages: [ghc-7.8.4,happy-1.19.4,alex-3.1.3],sources: [hvr-ghc]}}
    - env: STACK_RESOLVER=ghc-7.10
#      addons: {apt: {packages: [ghc-7.10.1,happy-1.19.4,alex-3.1.3],sources: [hvr-ghc]}}

  allow_failures:
    # We should track these failures, but they don't represent a
    # change or regression in our code:
    - env: STACK_RESOLVER=ghc-7.8
    - env: STACK_RESOLVER=ghc-7.10
    - env: STACK_RESOLVER=nightly
      

# Note: the distinction between `before_install` and `install` is not important.
before_install:
 - mkdir -p ~/.local/bin
 - export PATH=~/.local/bin:$PATH
 - if [ "$STACK_RESOLVER" == "" ];
   then STACK=stack;
   else STACK="stack --resolver=$STACK_RESOLVER";
   fi
 - wget https://github.com/commercialhaskell/stack/releases/download/v1.0.4/stack-1.0.4.2-linux-x86_64.tar.gz
 - tar xvf stack-1.0.4.2-linux-x86_64.tar.gz
 - mv -f stack-1.0.4.2-linux-x86_64/stack ~/.local/bin/
 - chmod a+x ~/.local/bin/stack

install:
 - export PATH=/opt/ghc/$GHCVER/bin:/opt/cabal/$CABALVER/bin:$PATH  
 - echo "$(ghc --version) [$(ghc --print-project-git-commit-id 2> /dev/null || echo '?')]"
 - $STACK setup
 - $STACK build

# Here starts the actual work to be performed for the package under test; any command which exits with a non-zero exit code causes the build to fail.
script:
 - if [ -f configure.ac ]; then autoreconf -i; fi
 - $STACK test --no-terminal
 - $STACK benchmark 
 - $STACK exec cabal check
 - $STACK exec cabal sdist   # tests that a source-distribution can be generated

# The following scriptlet checks that the resulting source distribution can be built & installed
 # - export SRC_TGZ=$(cabal info . | awk '{print $2 ".tar.gz";exit}') ;
 #   cd dist/;
 #   if [ -f "$SRC_TGZ" ]; then
 #      cabal install --force-reinstalls "$SRC_TGZ";
 #   else
 #      echo "expected '$SRC_TGZ' not found";
 #      exit 1;
 #   fi
